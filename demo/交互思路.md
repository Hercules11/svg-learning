这正是将系统从“只读”转向“可交互配置”的关键一步。

要实现这些功能，我们无法仅*靠* Leaflet 核心库完成。如您所想，我们需要自己编写“激活/取消”的状态管理、监听 `map.on('click')`、在点击时动态添加坐标点、在鼠标移动时绘制“幽灵线”...

...但幸运的是，我们不需要“重新发明轮子”。

有一个**Leaflet 的“黄金搭档”插件**，专门用于处理您所描述的所有交互功能： **`Leaflet.draw`**。

`Leaflet.draw` 提供了完整的 UI 和 API，用于在地图上绘制和编辑：

- 多边形 (Polygons)
- 折线 (Polylines)
- 矩形 (Rectangles)
- 圆形 (Circles)
- 标记 (Markers)

它完美地处理了所有复杂的内部状态，例如“现在正在画多边形的第三个点”、“用户正在拖动这个顶点”等等。

下面是一个核心 Demo，它使用 `Leaflet.draw` 来实现您需要的所有功能，并演示了如何将它与**您自己的按钮**（而不是插件默认的工具栏）集成起来。

---

### 🎛️ Leaflet.draw 交互式编辑 Demo

#### 准备工作：引入新库

您需要在 HTML 中额外引入 `Leaflet.draw` 的 CSS 和 JS。

```html
<link
	rel="stylesheet"
	href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<link
	rel="stylesheet"
	href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"
/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
```

#### Demo 代码 (HTML + JavaScript)

我们将添加几个按钮来手动激活“绘制”、“添加”和“编辑”模式。

```html
<!DOCTYPE html>
<html>
	<head>
		<title>甲板视图 - 交互式编辑 Demo</title>
		<meta charset="utf-8" />

		<link
			rel="stylesheet"
			href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
		/>
		<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

		<link
			rel="stylesheet"
			href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"
		/>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>

		<style>
			body {
				margin: 0;
				padding: 0;
			}
			#map {
				width: 100vw;
				height: 100vh;
				background-color: #333;
			}
			/* 我们的自定义工具栏 */
			.toolbar {
				position: absolute;
				top: 10px;
				left: 50px; /* Leaflet 默认缩放按钮在左侧 */
				z-index: 1000; /* 确保在地图上层 */
				background: white;
				padding: 5px;
				border-radius: 4px;
				border: 1px solid #ccc;
			}
			.toolbar button {
				margin: 2px;
				padding: 5px 10px;
			}
		</style>
	</head>
	<body>
		<div class="toolbar">
			<button id="drawPolygon">激活: 绘制危险区</button>
			<button id="addDevice">激活: 添加设备</button>
			<hr />
			<button id="editLayers">激活: 编辑/移动</button>
			<button id="saveChanges">保存更改</button>
			<button id="cancelEditing" style="display:none;">取消编辑</button>
		</div>

		<div id="map"></div>

		<script>
			// --- 1. 初始化地图 (和之前一样) ---
			const imgWidth = 1200;
			const imgHeight = 800;

			const map = L.map("map", {
				crs: L.CRS.Simple,
				minZoom: -2,
				maxZoom: 2,
			});

			const bounds = [
				[0, 0],
				[imgHeight, imgWidth],
			];
			const image = L.imageOverlay("deck-plan.svg", bounds).addTo(map);
			map.fitBounds(bounds);

			// --- 2. 核心: 设置 Leaflet.draw ---

			// (1) 创建一个 "FeatureGroup" 来存储所有可编辑的图层
			// 这是 Leaflet.draw 的要求
			const editableLayers = new L.FeatureGroup();
			map.addLayer(editableLayers);

			// (2) 初始化绘制和编辑的 "处理器" (Handlers)
			// 我们不使用默认工具栏，而是手动创建处理器
			const drawOptions = {
				polygon: {
					shapeOptions: {
						color: "#f03",
						fillOpacity: 0.4,
					},
					allowIntersection: false,
					showArea: true,
				},
				marker: {
					// (可选) 在这里指定您的自定义设备图标
					// icon: deviceIcon
				},
			};

			const polygonDrawer = new L.Draw.Polygon(map, drawOptions.polygon);
			const markerDrawer = new L.Draw.Marker(map, drawOptions.marker);

			// 编辑处理器需要知道它要编辑哪个图层组
			const editHandler = new L.EditToolbar.Edit(map, {
				featureGroup: editableLayers,
				// (可选) 禁用删除功能
				// remove: false
			});

			// --- 3. 绑定按钮事件 ---

			document.getElementById("drawPolygon").onclick = () => {
				polygonDrawer.enable(); // 激活多边形绘制
			};

			document.getElementById("addDevice").onclick = () => {
				markerDrawer.enable(); // 激活标记绘制
			};

			const editButton = document.getElementById("editLayers");
			const saveButton = document.getElementById("saveChanges");
			const cancelButton = document.getElementById("cancelEditing");

			editButton.onclick = () => {
				editHandler.enable(); // 激活编辑模式
				editButton.style.display = "none";
				saveButton.style.display = "inline-block";
				cancelButton.style.display = "inline-block";
			};

			saveButton.onclick = () => {
				editHandler.save(); // 保存更改
				editHandler.disable();
				editButton.style.display = "inline-block";
				saveButton.style.display = "none";
				cancelButton.style.display = "none";
			};

			cancelButton.onclick = () => {
				editHandler.revertLayers(); // 撤销更改
				editHandler.disable();
				editButton.style.display = "inline-block";
				saveButton.style.display = "none";
				cancelButton.style.display = "none";
			};

			// --- 4. 监听 Leaflet.draw 事件 ---

			// (1) 监听 "创建" 事件 (当一个形状绘制完成时)
			map.on(L.Draw.Event.CREATED, (event) => {
				const layer = event.layer;

				// 将新绘制的图层添加到我们的可编辑组中
				editableLayers.addLayer(layer);

				// (可选) 为新图层添加弹窗
				if (layer instanceof L.Marker) {
					layer.bindPopup("新设备 (点击编辑以移动)");
				} else if (layer instanceof L.Polygon) {
					layer.bindPopup("新危险区 (点击编辑以调整)");
				}

				// --- 关键: 获取数据以发送到后端 ---
				const geoJsonData = layer.toGeoJSON();
				console.log("新创建的图层 (GeoJSON):", JSON.stringify(geoJsonData));
				// 在这里，您可以立即调用一个 API 将这个 geoJsonData POST 到您的 Node.js 服务器
				// fetch('/api/deck/features', { method: 'POST', body: JSON.stringify(geoJsonData) });
			});

			// (2) 监听 "编辑" 事件 (当一个或多个图层被修改后点击 "保存" 时)
			map.on(L.Draw.Event.EDITED, (event) => {
				const layers = event.layers; // layers 是一个 LayerGroup

				// --- 关键: 获取被修改的数据以发送到后端 ---
				const editedGeoJsonData = layers.toGeoJSON();
				console.log(
					"被编辑的图层 (GeoJSON):",
					JSON.stringify(editedGeoJsonData)
				);

				// 在这里，您遍历被修改的图层并发起 PUT/PATCH 请求
				layers.eachLayer((layer) => {
					// 您需要一种方式来识别这个图层 (例如，在加载时给它绑定一个 _myDbId)
					// const id = layer._myDbId;
					// const data = layer.toGeoJSON();
					// fetch(`/api/deck/features/${id}`, { method: 'PUT', body: JSON.stringify(data) });
					console.log("图层被修改:", layer);
				});
			});

			// (3) 监听 "删除" 事件 (如果启用了删除功能)
			map.on(L.Draw.Event.DELETED, (event) => {
				const layers = event.layers;
				console.log("被删除的图层:", layers);

				// 在这里发起 DELETE 请求
				layers.eachLayer((layer) => {
					// const id = layer._myDbId;
					// fetch(`/api/deck/features/${id}`, { method: 'DELETE' });
				});
			});
		</script>
	</body>
</html>
```

### 核心逻辑解析

1.  **`editableLayers` (L.FeatureGroup)**
    这是最核心的概念。您必须创建一个图层组，`Leaflet.draw` 会将所有“可编辑”的图层（无论是新创建的还是从数据库加载的）都放在这个组里。
2.  **手动的处理器 (Handlers)**
    我们没有使用 `Leaflet.draw` 默认的工具栏，而是创建了 `polygonDrawer`, `markerDrawer`, 和 `editHandler` 的实例。这使我们可以通过自己的 HTML 按钮调用 `.enable()` 来精确控制何时激活哪个功能。
3.  **`draw:created` 事件**
    当用户完成一次绘制（例如双击闭合一个多边形，或在地图上点下一个标记）时触发。
    - 您从 `event.layer` 中获取这个新图层。
    - 您必须手动 `editableLayers.addLayer(layer);` 将它添加到可编辑组中。
    - 您使用 `layer.toGeoJSON()` 来获取标准格式的 GeoJSON 数据，这个数据就是您要 **POST 到后端数据库**的内容。
4.  **`draw:edited` 事件**
    当用户激活“编辑模式”，拖动了顶点或移动了图标，然后点击了我们提供的“保存更改”按钮（它调用 `editHandler.save()`）时触发。
    - 您从 `event.layers` 中获取所有被修改的图层。
    - 您同样使用 `.toGeoJSON()` 来获取更新后的数据，并将其 **PUT/PATCH 到后端**。
5.  **`draw:deleted` 事件**
    同理，当图层被删除时触发，用于通知后端删除数据。

### 给您的全栈开发建议

这个 Demo 只解决了“前端创建”，您的完整闭环是：

1.  **加载:** 页面加载时，从 Node.js 后端 `GET /api/deck/features` 获取所有已保存的 GeoJSON 数据。
2.  **渲染:** 使用 `L.geoJSON(data, { ... }).addTo(editableLayers);` 将从数据库读取的数据**直接添加**到 `editableLayers` 图层组中。
    - 在 `L.geoJSON` 的 `onEachFeature` 选项中，您可以将数据库的 `_id` 绑定到图层上（例如 `layer._myDbId = feature.properties.dbId;`），这样在“编辑”时您就知道要更新哪条数据。
3.  **创建:** 使用本 Demo 中的 `draw:created` 事件，将 `layer.toGeoJSON()` **POST** 到后端。
4.  **编辑:** 使用 `draw:edited` 事件，将 `layers.toGeoJSON()` **PUT/PATCH** 到后端。
5.  **删除:** 使用 `draw:deleted` 事件，将图层的 ID **DELETE** 到后端。

这样，您就拥有了一个完整的、以甲板视图为核心的、持久化的交互式配置系统。
